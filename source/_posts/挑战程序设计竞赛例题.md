layout: post
title: 挑战程序设计竞赛例题
date: 2017-01-01 10:06:58
tags:
---
## 贪心算法

只考虑当前最优策略

### POJ 3253 Fench Repair

农夫约翰为了修理栅栏，要将一块很长的木板切割成N块。准备切成的木板的长度为L1,L2,…,LN，未切割前木板的长度恰好为切割后木板长度的总和。每次切断木板时，需要的开销为这块木板的长度。例如长度为21的木板要切成长度为5,8,8的三块木板。长21的木板切成长为13和8的板时，开销为21。再将长度为13的板切成长度为5和8的板时，开销是13.于是合计开销是34.请求出按照目标要求将木板切割完最小的开销是多少。

限制条件：
* 1<=N<=20000
* 0<=Li<=50000

解题思路：
* 二叉树数据模型，每个节点表示切割后的木板长度
* 总开销=叶子节点\*节点深度
* 为了让开销最小，越小的叶子节点，节点深度越深
* 每个叶子节点都有兄弟节点（一切为二）
* 选择当前N块木板中最短的两块进行相加并递归至N=1
* 使用最小堆进行节点筛选

## 动态规划
### 背包系列问题
[背包问题九讲 by dd_engi](http://love-oriented.com/pack/)

#### 01背包问题

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。

解题思路：
* 设：放入第 i 个物品前的价值为 j，比较放入与不放入的递归后结果
> rec(i+1, j)
> rec(i+1, j-w[i])+c[i])
* 递归找出当前子集中的最优解

优化思路：
* 缓存/记忆化搜索 O(kn)
* 通过递归算法导出递推式，使用二维数组降低空间复杂度

基本结论：
> f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}

#### 完全背包问题
有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。

基本结论：

根据01背包问题的结论得出：f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}

优化 O(VN) 算法：
```
这个算法使用一维数组，先看伪代码：
for i=1..N
    for v=0..V
        f[v]=max{f[v],f[v-cost]+weight}
你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。
这是因为要保证第i次循环中的状态f[i][v]是由状态f[i-1][v-c[i]]递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选
入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果f[i-1][v-c[i]]。而现在完全背包的特点恰是每种物品可选无限件，
所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果f[i][v-c[i]]，所以就可以并且必须采用v=0..V的
顺序循环。这就是这个简单的程序为何成立的道理。
```
数学推论
```
f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<=v}
 = max{f[i-1][v],(f[i-1][v-k*c[i]+k*w[i]|1<=k*c[i]<=v)}
 = max{f[i-1][v],f[i][v-c[i]]+w[i]} //第i件物品至少选了一次
```

### 多重部分和问题
题目: 有n种不同大小的数字a, 每种各m个. 判断是否可以从这些数字之中选出若干使它们的和恰好为K。

限制条件：
* 1<=n<=100
* 1<=ai,mi <=100000
* 1<=K<=100000

解题思路：
* dp[i+1][j]:=用前i种数加和得到j时，第i种数最多能剩余多少个
* 判断 dp[n][K] 是否大于0

<table><tr><td>dp[i+1][j] =</td><td>mi</td><td>dp[i][j]>0</td><tr/><tr><td>dp[i+1][j] =</td><td>-1</td><td>j&lt;ai或者dp[i+1][j-ai]&lt;=0</td></tr><tr><td>dp[i+1][j] =</td><td>dp[i+1][j-ai]-1</td><td>others</td></tr></table>

```
a = {3,5,8}
m = {3,2,2}
iter i to n
	iter j to K
		i=0: dp[0]=3, dp[3]=2, dp[6]=1, dp[9]=0
		i=1: dp[0]=2, dp[3]=2, dp[5]=1, dp[6]=2, dp[8]=dp[3]-1=1, dp[11]=dp[6]-1=1
        ...
    end
end
```